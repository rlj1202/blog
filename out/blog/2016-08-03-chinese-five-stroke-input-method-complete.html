<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0" class="jsx-834064900"/><link rel="icon" href="/blog/favicon.ico" class="jsx-834064900"/><title class="jsx-1900133614">한자 오필 입력기 개발 - 완성</title><meta name="next-head-count" content="4"/><link rel="preload" href="/blog/_next/static/D0XTK0MEKRJDXLhC_InxX/pages/_app.js" as="script"/><link rel="preload" href="/blog/_next/static/D0XTK0MEKRJDXLhC_InxX/pages/blog/%5B...slug%5D.js" as="script"/><link rel="preload" href="/blog/_next/static/runtime/webpack-c212667a5f965e81e004.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/framework.619a4f70c1d4d3a29cbc.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/commons.020a96d8a8e71e9e3362.js" as="script"/><link rel="preload" href="/blog/_next/static/runtime/main-d76a4f4aadf0225115f4.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/e6dc419047dac61ef10415aaccc4c72c1149af9c.5637e4aab0992574c455.js" as="script"/><style id="__jsx-505471054">.top.jsx-1900133614{margin:0;background-color:#ff6565;box-shadow:0 0 5pt black;color:white;}.fixed-width.jsx-1900133614{max-width:600pt;min-width:0;padding:0 20pt;margin:0 auto;}.header.jsx-1900133614{padding-top:20pt;padding-bottom:20pt;}.header.jsx-1900133614 .navigator.jsx-1900133614{margin-bottom:20pt;}.header.jsx-1900133614 .navigator-link.jsx-1900133614{font-size:8pt;color:black;background-color:white;border-radius:16pt;padding:2pt 6pt;}.header.jsx-1900133614 .date.jsx-1900133614{margin:10pt 0;}.header.jsx-1900133614 .title.jsx-1900133614{font-size:35pt;font-weight:bold;margin:10pt 0;}.header.jsx-1900133614 .subtitle.jsx-1900133614{font-weight:bold;margin:10pt 0;}.tags.jsx-1900133614{margin-top:10pt;}.tag.jsx-1900133614{margin-right:4pt;padding:2pt 4pt;font-size:9pt;border-radius:3pt;background-color:#0000007a;display:inline-block;}.content-wrapper.jsx-1900133614{margin:20pt 0;}hr.jsx-1900133614{border:0;height:1px;background-color:#00000014;margin:20pt 0;}.prev-post.jsx-1900133614 .heading.jsx-1900133614,.next-post.jsx-1900133614 .heading.jsx-1900133614{margin-bottom:5pt;}.prev-post.jsx-1900133614 .title.jsx-1900133614,.next-post.jsx-1900133614 .title.jsx-1900133614{font-style:italic;color:#7d7d7d;}.next-post.jsx-1900133614{text-align:right;}.footer.jsx-1900133614{text-align:center;font-size:9pt;margin:20pt 0;}</style><style id="__jsx-1919476713">code{background-color:#dddddd;font-size:inherit;padding:2pt 4pt;border-radius:2pt;}.content img,.content iframe{max-width:100%;}</style><style id="__jsx-834064900">@import url(https://fonts.googleapis.com/earlyaccess/notosanskr.css);html,body{margin:0;padding:0;font-family:'Noto Sans KR',sans-serif;}a{color:inherit;-webkit-text-decoration:none;text-decoration:none;}*{box-sizing:border-box;}</style></head><body><div id="__next"><div class="jsx-834064900 container"><div class="jsx-1900133614 top"><div class="jsx-1900133614 header fixed-width"><div class="jsx-1900133614 navigator"><span class="jsx-1900133614 navigator-link"><a class="jsx-1900133614" href="/blog/">home</a></span> &gt;<span class="jsx-1900133614 navigator-link">blog</span></div><div class="jsx-1900133614 date">2016-08-03 01:49:00 +0900</div><div class="jsx-1900133614 title"><a class="jsx-1900133614" href="/blog/blog/2016-08-03-chinese-five-stroke-input-method-complete">한자 오필 입력기 개발 - 완성</a></div><div class="jsx-1900133614 subtitle"></div><div class="jsx-1900133614 tags"><span class="jsx-1900133614 tag">#<!-- -->한자오필입력기</span></div></div></div><div class="jsx-1900133614 content-wrapper"><div class="jsx-1900133614 content fixed-width"><h1>한자 오필 입력기</h1><h2>개발하게 된 동기</h2><p>학교에서 중국어를 배우는데, 왜이렇게 중국어가 재밌는지, 휴대폰으로 한자를 입력할 방법을 찾다가 획만으로 모든 한자를 입력하는 입력기를 알게되어 설치하게 되었다.</p><p>이 방법을 컴퓨터 에서도 쓰고 싶어서 PC판 오필입력기를 찾는데, 도통 나오질 않고 겨우 찾은 프로그램은 이미 휴대폰 자판에 익숙해진 나에게 너무 불편했다. 획 자판이 일렬로 나열되어 있었고 검색 결과 밑에 우리나라 한자 음이 표기 되면 좋겠다라는 생각에 그럴바에 직접 만들어 버리지 뭐, 하면서 시작하게 된것이 C언어를 배워야 하는 대 프로젝트로 커지고 말았다.</p><h2>오필입력이란?</h2><p>간단히 말해, 한자의 획을 <em>다섯가지로 구분</em>하여 획 수 대로 입력하는 방법.
예를 들어, &quot;열 십 十&quot;같은 한자의 경우 가로획, 세로획 두가지 획이 있으므로 해당하는 획 버튼을 순서대로 누른다.</p><span><!-- more --></span><p>여기서 중요한 점은 <em>획순</em>을 지켜야 한다는 것이다.
자세한 사항은 필자가 위키백과에 정리해 두었다.</p><p>위키백과 &quot;오필화수입법&quot;: <a href="https://ko.wikipedia.org/wiki/%EC%98%A4%ED%95%84%ED%99%94%EC%88%98%EC%9E%85%EB%B2%95">https://ko.wikipedia.org/wiki/오필화수입법</a></p><p>위키에도 나와있듯이, 이 입력법의 장점은 한자의 모양만 알고 있으면 입력할 수 있다는 것 이지만, 한자 획순의 규칙을 알아야 하고, 규칙을 알고 있다 하더라도 대부분의 한자들은 규칙대로 입력하기 힘들다. 특히 &quot;벚 우 友&quot;와 &quot;반할 반 反&quot;자는 이 입력법으로 입력하려고 하면 처음쓰는 사람에게는 혼란을 야기하기 쉽다. 맨 첫번째 획만 다르고 나머지는 다 똑같다.</p><p>그럼에도 불구하고 난 이 입력법이 너무 좋다. 너무 매력적이기 때문이다.</p><span><center><img src="/assets/screenshot.png" width="400px" /></center></span><h1>프로그램으로 구현하기 까지</h1><p>이를 프로그램으로 구현하기 위해서는, 어떤 한자에 대한 획 정보를 담고있는 표가 필요한데, 직접 만들기는 뭐하고 인터넷을 검색하던 도중에 아니나 다를까, 이미 누군가 파싱하기 쉽도록 만들어 두었다.</p><p>획 테이블: <a href="https://code.google.com/archive/p/ibus-t9/issues/3">https://code.google.com/archive/p/ibus-t9/issues/3</a></p><p>이 개발자는 이미 한참전에 개발을 멈춘것 같다. 완성이 된것인지는 자세히 알아보지 않아서 모르지만 좋은 자료다!</p><p>이제 이 테이블을 가지고 해야하는 일은 테이블 검색이다. 세상에나. 이 테이블에는 20000개는 넘는 한자데이터들이 있다. 지금까지 이렇게 많은 데이터는 다뤄 본적이 없어서 막막했지만 사전처럼 일정한 규칙이 있었기에 적당한 알고리즘이 있을거라고 생각했다. 찾은 알고리즘은 바로 &quot;이분법적 검색(binary search)&quot; 이다. 정렬되어있는 데이터셋에서 매우 강력한 힘을 발휘한다. 한번 루프를 돌 때 마다 검색의 범위가 반으로 줄기 때문에 속도가 미친듯이 빠르다.</p><p>물론 정렬이 되어있어야 하고, 어떤 방식으로 정렬이 되어있는지 알아야 한다는 문제가 있다.</p><p>그래서 두 가지의 데이터 베이스를 만들었다.
첫번째 데이터 베이스는 획수의 길이를 고려하여, 짧은것이 우선순위가 높은 정렬이고, 두번째 데이터 베이스는 길이는 고려치 않고 획의 종류로만 정렬한 데이터 이다.</p><p>첫번째와 두번째 테이블을 가지고 검색했을때, 다른 이점이 있는데 획수를 고려했을때의 결과는 획수를 고려했기 때문에 획수대로 검색할 수 있다는 것이고, 그 때문에 획수는 같은데 비슷한 한자들을 나열할 수 있다.
두번째 테이블 같은 경우는 같은 부수를 가지는 한자들을 많이 찾을 수 있다. 예를 들어 삼수변을 검색했다면 삼수변을 부수로 두는 한자들이 나올것이다. 만약, 첫번째 테이블에서 삼수변을 찾으면 3획짜리 한자들이 나올것이다.</p><p>둘중 하나를 골라 하나만 쓰기에는 좀 그래서 각 테이블에서 5개씩 검색하여 둘다 보여주기로 결정했다.</p><p>그 다음 GUI를 만들고 모바일 입력기 처럼 버튼을 만들어 획을 입력하도록 하고 검색한 결과를 열개의 버튼에 순서대로 표시하여 해당 버튼을 누르면 그 한자가 커서에 나오도록 했다.</p><p>그 다음에 검색결과에 우리나라 한자 음이 나오면 좋겠다 싶어서 이번에는 그에 대한 데이터베이스를 찾다가 Unihan이라는 것을 알게 되었다.</p><p>Unihan: <a href="https://unicode.org/charts/unihan.html">https://unicode.org/charts/unihan.html</a></p><p>이 프로젝트는 한중일 한자의 대한 데이터를 수집하여 현재 zip파일 형태로 데이터 베이스를 제공하고 있다. 한중일의 한자들중 같은 한자이나, 모양이 다른 한자들에 대해서도 모두 정리해 두었고 일본어 발음, 중국어 발음, 한국어 발음, 광둥어 발음등 발음에 대한 정보도 모두 들어있고 영어로 뜻 또한 들어있다.
데이터 베이스 중에서도 Unihan_Readings.txt 라는 파일에 kHangul이라는 속성에 한국어 한자 발음에 대한 정보가 들어있다. 이 데이타 베이스도 용량이 방대하기 때문에 이분법적 검색 알고리즘을 사용했다.(거의 만능)</p><p>이제 기본적인 틀은 모두 갖추었으나, 사용하는데 너무 불편하다. 그 이유는 마우스로 일일이 눌러야 하기 때문이다. 그래서 키보드 입력을 지원해 보기로 했으나, 자바로 개발했기에 컴퓨터 자체의 키보드 입력을 받는데 문제가 있다. 그래서 전역 키보드 후킹을 해야하는데 네이티브 라이브러리를 이용해야 한다.</p><p>물론 오픈소스로 네이티브 키보드 후킹 라이브러리가 존재하나, 진짜 내가 원하는 기능이 없었다. 바로 키보드 입력을 &#x27;취소&#x27;시켜버리는 것이다. 이거 하나때문에 내가 직접 키보드 후킹을 만들어야지, 라고 생각했다. 사실 엄청 좋은 기능이지만, 이를 구현하려면 배울게 하나둘이 아니었다.</p><p>일단 가장 기본중의 기본 언어인 C를 선택하였고 dll을 만들어야 했다.
키보드 후킹을 하기위해서는, 프로세스마다 dll을 inject하여 jvm에 알려주어야 하는데 처음에는 다 무슨 <s>개</s>소린지 알아듯질 못했다.</p><p>프로세스간 메모리 공간이 불리되어 thread-safe한 객체일 지라도 한 프로세스 내에서만 유효하다는 것, 핸들은 한 쓰레드 내에서만 유효 하다는것, 포인터와 이중 포인터의 개념, 이름있는 파이프, 구조체, jni의 사용 등 배우고 이해해야 하는것이 많았고 두 세번 갈아 엎어서 완성했다.</p><p>실제로 사용하면서도 문제가 있었는데, 키보드 입력 취소가 목적이었던 터라 자바에서 함수를 빨리 return 해주지 않으면 dll에서 계속 기다리고 있는 탓에(그것도 KeyboardProc에서) 시스템의 입력 전체가 맛이 가는 부작용이 있었다. 물론 이 문제는 프로그래밍 하면서 게속 유념해야 할 것이다. 그래서 딜레이가 생기는 일 이라면 자바에서 쓰레드를 생성해서 이벤트 함수는 빨리 리턴해 주고 후에 작업을 해 주어야 한다.</p><h1>완성</h1><span><center><iframe width="560" height="315" src="//sendvid.com/embed/qgp3760s" frameborder="0" allowfullscreen></iframe></center></span><hr class="jsx-1900133614"/><div class="jsx-1900133614 prev-post"><h2 class="jsx-1900133614 heading">이전글</h2><span class="jsx-1900133614 title">&quot;The test title&quot;</span></div><div class="jsx-1900133614 next-post"><h2 class="jsx-1900133614 heading">다음글</h2><span class="jsx-1900133614 title">&quot;Another post title&quot;</span></div><hr class="jsx-1900133614"/><footer class="jsx-1900133614 footer">Github.io - Copyright(c) 2020. Jisu Sim(RedLaboratory)</footer></div></div><style>
            .container {
            }
            </style></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"slug":["2016-08-03-chinese-five-stroke-input-method-complete"],"frontmatter":"{\"layout\":\"post\",\"title\":\"한자 오필 입력기 개발 - 완성\",\"categories\":\"programming\",\"tags\":\"한자오필입력기\",\"date\":\"2016-08-03 01:49:00 +0900\"}","markdownbody":"\n# 한자 오필 입력기\n\n## 개발하게 된 동기\n학교에서 중국어를 배우는데, 왜이렇게 중국어가 재밌는지, 휴대폰으로 한자를 입력할 방법을 찾다가 획만으로 모든 한자를 입력하는 입력기를 알게되어 설치하게 되었다.\n\n이 방법을 컴퓨터 에서도 쓰고 싶어서 PC판 오필입력기를 찾는데, 도통 나오질 않고 겨우 찾은 프로그램은 이미 휴대폰 자판에 익숙해진 나에게 너무 불편했다. 획 자판이 일렬로 나열되어 있었고 검색 결과 밑에 우리나라 한자 음이 표기 되면 좋겠다라는 생각에 그럴바에 직접 만들어 버리지 뭐, 하면서 시작하게 된것이 C언어를 배워야 하는 대 프로젝트로 커지고 말았다.\n\n## 오필입력이란?\n간단히 말해, 한자의 획을 *다섯가지로 구분*하여 획 수 대로 입력하는 방법.\n예를 들어, \"열 십 十\"같은 한자의 경우 가로획, 세로획 두가지 획이 있으므로 해당하는 획 버튼을 순서대로 누른다.\n\n\u003c!-- more --\u003e\n\n여기서 중요한 점은 *획순*을 지켜야 한다는 것이다.\n자세한 사항은 필자가 위키백과에 정리해 두었다.\n\n위키백과 \"오필화수입법\": [https://ko.wikipedia.org/wiki/오필화수입법](https://ko.wikipedia.org/wiki/%EC%98%A4%ED%95%84%ED%99%94%EC%88%98%EC%9E%85%EB%B2%95)\n\n위키에도 나와있듯이, 이 입력법의 장점은 한자의 모양만 알고 있으면 입력할 수 있다는 것 이지만, 한자 획순의 규칙을 알아야 하고, 규칙을 알고 있다 하더라도 대부분의 한자들은 규칙대로 입력하기 힘들다. 특히 \"벚 우 友\"와 \"반할 반 反\"자는 이 입력법으로 입력하려고 하면 처음쓰는 사람에게는 혼란을 야기하기 쉽다. 맨 첫번째 획만 다르고 나머지는 다 똑같다.\n\n그럼에도 불구하고 난 이 입력법이 너무 좋다. 너무 매력적이기 때문이다.\n\n\u003ccenter\u003e\u003cimg src=\"/assets/screenshot.png\" width=\"400px\" /\u003e\u003c/center\u003e\n\n# 프로그램으로 구현하기 까지\n\n이를 프로그램으로 구현하기 위해서는, 어떤 한자에 대한 획 정보를 담고있는 표가 필요한데, 직접 만들기는 뭐하고 인터넷을 검색하던 도중에 아니나 다를까, 이미 누군가 파싱하기 쉽도록 만들어 두었다.\n\n획 테이블: [https://code.google.com/archive/p/ibus-t9/issues/3](https://code.google.com/archive/p/ibus-t9/issues/3)\n\n이 개발자는 이미 한참전에 개발을 멈춘것 같다. 완성이 된것인지는 자세히 알아보지 않아서 모르지만 좋은 자료다!\n\n이제 이 테이블을 가지고 해야하는 일은 테이블 검색이다. 세상에나. 이 테이블에는 20000개는 넘는 한자데이터들이 있다. 지금까지 이렇게 많은 데이터는 다뤄 본적이 없어서 막막했지만 사전처럼 일정한 규칙이 있었기에 적당한 알고리즘이 있을거라고 생각했다. 찾은 알고리즘은 바로 \"이분법적 검색(binary search)\" 이다. 정렬되어있는 데이터셋에서 매우 강력한 힘을 발휘한다. 한번 루프를 돌 때 마다 검색의 범위가 반으로 줄기 때문에 속도가 미친듯이 빠르다.\n\n물론 정렬이 되어있어야 하고, 어떤 방식으로 정렬이 되어있는지 알아야 한다는 문제가 있다.\n\n그래서 두 가지의 데이터 베이스를 만들었다.\n첫번째 데이터 베이스는 획수의 길이를 고려하여, 짧은것이 우선순위가 높은 정렬이고, 두번째 데이터 베이스는 길이는 고려치 않고 획의 종류로만 정렬한 데이터 이다.\n\n첫번째와 두번째 테이블을 가지고 검색했을때, 다른 이점이 있는데 획수를 고려했을때의 결과는 획수를 고려했기 때문에 획수대로 검색할 수 있다는 것이고, 그 때문에 획수는 같은데 비슷한 한자들을 나열할 수 있다.\n두번째 테이블 같은 경우는 같은 부수를 가지는 한자들을 많이 찾을 수 있다. 예를 들어 삼수변을 검색했다면 삼수변을 부수로 두는 한자들이 나올것이다. 만약, 첫번째 테이블에서 삼수변을 찾으면 3획짜리 한자들이 나올것이다.\n\n둘중 하나를 골라 하나만 쓰기에는 좀 그래서 각 테이블에서 5개씩 검색하여 둘다 보여주기로 결정했다.\n\n그 다음 GUI를 만들고 모바일 입력기 처럼 버튼을 만들어 획을 입력하도록 하고 검색한 결과를 열개의 버튼에 순서대로 표시하여 해당 버튼을 누르면 그 한자가 커서에 나오도록 했다.\n\n그 다음에 검색결과에 우리나라 한자 음이 나오면 좋겠다 싶어서 이번에는 그에 대한 데이터베이스를 찾다가 Unihan이라는 것을 알게 되었다.\n\nUnihan: [https://unicode.org/charts/unihan.html](https://unicode.org/charts/unihan.html)\n\n이 프로젝트는 한중일 한자의 대한 데이터를 수집하여 현재 zip파일 형태로 데이터 베이스를 제공하고 있다. 한중일의 한자들중 같은 한자이나, 모양이 다른 한자들에 대해서도 모두 정리해 두었고 일본어 발음, 중국어 발음, 한국어 발음, 광둥어 발음등 발음에 대한 정보도 모두 들어있고 영어로 뜻 또한 들어있다.\n데이터 베이스 중에서도 Unihan_Readings.txt 라는 파일에 kHangul이라는 속성에 한국어 한자 발음에 대한 정보가 들어있다. 이 데이타 베이스도 용량이 방대하기 때문에 이분법적 검색 알고리즘을 사용했다.(거의 만능)\n\n이제 기본적인 틀은 모두 갖추었으나, 사용하는데 너무 불편하다. 그 이유는 마우스로 일일이 눌러야 하기 때문이다. 그래서 키보드 입력을 지원해 보기로 했으나, 자바로 개발했기에 컴퓨터 자체의 키보드 입력을 받는데 문제가 있다. 그래서 전역 키보드 후킹을 해야하는데 네이티브 라이브러리를 이용해야 한다.\n\n물론 오픈소스로 네이티브 키보드 후킹 라이브러리가 존재하나, 진짜 내가 원하는 기능이 없었다. 바로 키보드 입력을 '취소'시켜버리는 것이다. 이거 하나때문에 내가 직접 키보드 후킹을 만들어야지, 라고 생각했다. 사실 엄청 좋은 기능이지만, 이를 구현하려면 배울게 하나둘이 아니었다.\n\n일단 가장 기본중의 기본 언어인 C를 선택하였고 dll을 만들어야 했다.\n키보드 후킹을 하기위해서는, 프로세스마다 dll을 inject하여 jvm에 알려주어야 하는데 처음에는 다 무슨 \u003cs\u003e개\u003c/s\u003e소린지 알아듯질 못했다.\n\n프로세스간 메모리 공간이 불리되어 thread-safe한 객체일 지라도 한 프로세스 내에서만 유효하다는 것, 핸들은 한 쓰레드 내에서만 유효 하다는것, 포인터와 이중 포인터의 개념, 이름있는 파이프, 구조체, jni의 사용 등 배우고 이해해야 하는것이 많았고 두 세번 갈아 엎어서 완성했다.\n\n실제로 사용하면서도 문제가 있었는데, 키보드 입력 취소가 목적이었던 터라 자바에서 함수를 빨리 return 해주지 않으면 dll에서 계속 기다리고 있는 탓에(그것도 KeyboardProc에서) 시스템의 입력 전체가 맛이 가는 부작용이 있었다. 물론 이 문제는 프로그래밍 하면서 게속 유념해야 할 것이다. 그래서 딜레이가 생기는 일 이라면 자바에서 쓰레드를 생성해서 이벤트 함수는 빨리 리턴해 주고 후에 작업을 해 주어야 한다.\n\n# 완성\n\n\u003ccenter\u003e\u003ciframe width=\"560\" height=\"315\" src=\"//sendvid.com/embed/qgp3760s\" frameborder=\"0\" allowfullscreen\u003e\u003c/iframe\u003e\u003c/center\u003e\n"},"__N_SSG":true},"page":"/blog/[...slug]","query":{"slug":["2016-08-03-chinese-five-stroke-input-method-complete"]},"buildId":"D0XTK0MEKRJDXLhC_InxX","assetPrefix":"/blog","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/blog/_next/static/runtime/polyfills-b10afcedf826ebd862ad.js"></script><script async="" data-next-page="/_app" src="/blog/_next/static/D0XTK0MEKRJDXLhC_InxX/pages/_app.js"></script><script async="" data-next-page="/blog/[...slug]" src="/blog/_next/static/D0XTK0MEKRJDXLhC_InxX/pages/blog/%5B...slug%5D.js"></script><script src="/blog/_next/static/runtime/webpack-c212667a5f965e81e004.js" async=""></script><script src="/blog/_next/static/chunks/framework.619a4f70c1d4d3a29cbc.js" async=""></script><script src="/blog/_next/static/chunks/commons.020a96d8a8e71e9e3362.js" async=""></script><script src="/blog/_next/static/runtime/main-d76a4f4aadf0225115f4.js" async=""></script><script src="/blog/_next/static/chunks/e6dc419047dac61ef10415aaccc4c72c1149af9c.5637e4aab0992574c455.js" async=""></script><script src="/blog/_next/static/D0XTK0MEKRJDXLhC_InxX/_buildManifest.js" async=""></script><script src="/blog/_next/static/D0XTK0MEKRJDXLhC_InxX/_ssgManifest.js" async=""></script></body></html>